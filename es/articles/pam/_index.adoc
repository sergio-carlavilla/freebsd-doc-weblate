---
title: Módulos de autentificación conectables
authors:
  - author: Dag-Erling Smørgrav
copyright: 2001-2003 Networks Associates Technology, Inc.
releaseinfo: "$FreeBSD$" 
trademarks: ["pam", "freebsd", "linux", "opengroup", "sun", "general"]
---

= Módulos de autentificación conectables
:doctype: article
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:source-highlighter: rouge
:experimental:

[.abstract-title]
Resumen

Este artículo describe los principios y mecanismos subyacentes de la libreria Pluggable Authentication Modules (PAM), y explica cómo configurar PAM, cómo integrar PAM en aplicaciones y cómo escribir módulos PAM.

'''

toc::[]

[[pam-intro]]
== Introducción

La libreria Pluggable Authentication Modules (PAM) es una API para servicios relacionados con la autenticación que permite al administrador del sistema añadir nuevos métodos de autenticación simplemente instalando nuevos módulos PAM y modificando las políticas de autenticación editando el archivo de configuración.

PAM fue definido y desarrollado en 1995 por Vipin Samar y Charlie Lai de Sun Microsystems, y no ha cambiado mucho desde entonces. En 1997, el Open Group publicó la especificación preliminar X/Open Single Sign-on (XSSO), que estandarizó la API de PAM y añadió las extensiones para el single sign-on. En el momento de escribir este artículo, esta especificación aún no se ha adoptado como estándar.

Aunque este artículo se centra principalmente en FreeBSD 5.x, el cual hace uso de OpenPAM, también se debería poder aplicar a FreeBSD 4.x, el cual hace uso de Linux-PAM, y en otros sistemas operativos, como Linux y Solaris(TM).

[[pam-terms]]
== Términos y convenciones

[[pam-definitions]]
=== Definiciones

La terminología que rodea PAM es bastante confusa. Ni el documento original de Samar y Lai, ni la especificación XSSO hicieron ningún intento de definir formalmente los términos para los diversos actores y entidades involucradas en PAM, y los términos que usan (pero no definen) a veces son engañosos y ambiguos. El primer intento de establecer una terminología coherente e inequívoca fue un documento técnico escrito por Andrew G. Morgan (autor de Linux-PAM) en 1999. Si bien la terminología elegida por parte de Morgan fue un gran avance, en opinión de este autor, no es de ninguna manera perfecta. Las definiciones que se muestran son un intento, fuertemente inspiradas por Morgan, de definir de forma precisa y sin ambigüedades los terminos para todos los actores y entidades involucradas en PAM.

[.glosslist]
account::
El conjunto de credenciales que el applicant solicita al arbitrator.

applicant::
El usuario o entidad que solicita la autenticación.

arbitrator::
El usuario o entidad que tiene los privilegios necesarios para verificar las credenciales del applicant y la autoridad para otorgar o denegar la solicitud.

chain::
Una secuencia de módulos que se invocarán en respuesta a una solicitud PAM. El chain incluye información sobre el orden en el que invocar los módulos, qué argumentos pasarles y cómo interpretar los resultados.

client::
La aplicación responsable de iniciar una solicitud de autenticación en nombre del applicant y de obtener la información de autenticación necesaria de él.

facility::
Uno de los cuatro grupos básicos de funcionalidad proporcionados por PAM: authentication, account management, session management y authentication token update.

module::
Una colección de una o más funciones relacionadas que implementan una facility de autenticación particular, recogida en un único archivo binario (normalmente cargable dinámicamente) e identificado por un solo nombre.

policy::
El conjunto completo de instrucciones de configuración que describen cómo manejar las solicitudes PAM para un servicio en particular. Una policy normalmente consta de cuatro chains, una para cada facility, aunque algunos servicios no utilizan las cuatro facilities.

server::
La aplicación que actúa en nombre del arbitrator para conversar con el client, recuperar información de autenticación, verificar las credenciales del applicant y otorgar o rechazar solicitudes.

service::
Una clase de servidores que proporcionan una funcionalidad similar o relacionada y que requieren una autenticación similar. Las políticas de PAM se definen por cada service, por lo que todos los servidores que reclaman el mismo nombre de service estarán sujetos a la misma política.

session::
El contexto dentro del cual el servidor presta el servicio al applicant. Una de las cuatro facilities de PAM, la gestión de sesiones, se ocupa exclusivamente de establecer y destruir este contexto.

token::
Un chunk de información asociado con la cuenta, como una contraseña o frase, que el applicant debe proporcionar para probar su identidad.

transaction::
Una secuencia de solicitudes del mismo applicant a la misma instancia del mismo servidor, comenzando con la autenticación y la configuración de la sesión y terminando con el desmantelamiento de la sesión.

[[pam-usage-examples]]
=== Ejemplos de uso

Esta sección tiene como objetivo ilustrar los significados de algunos de los términos definidos anteriormente mediante un puñado de ejemplos simples.

=== El cliente y el servidor son uno

Este ejemplo sencillo muestra a `alice` usando el comando man:su[1] para convertirse en `root`.

[source,bash]
....
% whoami
alice
% ls -l `which su`
-r-sr-xr-x  1 root  wheel  10744 Dec  6 19:06 /usr/bin/su
% su -
Password: xi3kiune
# whoami
root
....

* El applicant es `alice`.
* El account es `root`.
* El proceso de utilizar man:su[1] es tanto cliente como servidor.
* El token de autenticación es `xi3kiune`.
* El arbitrator es `root`, por lo que el comando man:su[1] es setuid `root`.

=== El cliente y el servidor están separados

El siguiente ejemplo muestra a `eve` intentando iniciar una conexión por man:ssh[1] a `login.example.com`, solicita iniciar sesión como `bob`, y tiene éxito. ¡Bob debería de haber elegido una contraseña mejor!

[source,bash]
....
% whoami
eve
% ssh bob@login.example.com
bob@login.example.com's password: god
Last login: Thu Oct 11 09:52:57 2001 from 192.168.0.1
Copyright (c) 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
	The Regents of the University of California.  All rights reserved.
FreeBSD 4.4-STABLE (LOGIN) #4: Tue Nov 27 18:10:34 PST 2001

Welcome to FreeBSD!
%
....

* El applicant es `eve`.
* El client es el proceso man:ssh[1] de Eve.
* El server es el proceso man:sshd[8] en `login.example.com`
* El account es `bob`.
* El token de autenticación es `god`.
* Aunque esto no se muestra en este ejemplo, el arbitrator es `root`.

=== Política de ejemplo

Lo que se muestra a continuación, es la política predeterminada de FreeBSD para `sshd`:

[.programlisting]
....
sshd	auth		required	pam_nologin.so	no_warn
sshd	auth		required	pam_unix.so	no_warn try_first_pass
sshd	account		required	pam_login_access.so
sshd	account		required	pam_unix.so
sshd	session		required	pam_lastlog.so	no_fail
sshd	password	required	pam_permit.so
....

* Esta política se aplica al servicio `sshd` (que no está restringido necesariamente al servidor man:sshd[8]).
* `auth`, `account`, `session` y `password` son facilities.
* [.filename]#pam_nologin.so#, [.filename]#pam_unix.so#, [.filename]#pam_login_access.so#, [.filename]#pam_lastlog.so# y [.filename]#pam_permit.so# son modules. Está claro que a partir de este ejemplo, [.filename]#pam_unix.so# proporciona al menos dos funciones (autenticación y administración de cuentas).

[[pam-essentials]]
== PAM Essentials

[[pam-facilities-primitives]]
=== Facilities y primitives

La API de PAM ofrece seis primitives de autenticación diferentes agrupadas en cuatro facilities, que se describen a continuación.

`auth`::
_Authentication._ Esta facility se ocupa de autenticar al applicant y establecer las credenciales de la cuenta. Proporciona dos primitives:

** man:pam_authenticate[3] autentica al applicant, normalmente, solicitando un token de autenticación y comparándolo con un valor almacenado en una base de datos u obtenido de un servidor de autenticación.
** man:pam_setcred[3] establece credenciales de la cuenta, como el ID del usuario, membresía de grupo y límites de recursos.

`account`::
_Account management._ Esta función se encarga de los problemas de disponibilidad con las cuentas, que no están relacionados con la autenticación, como restricciones de acceso según la hora del día o la carga del servidor de trabajo. Proporciona una primitive única:

** man:pam_acct_mgmt[3] verifica que la cuenta solicitada esté disponible.

`session`::
_Session management._ Está función maneja las tareas asociadas con la configuración de la sesión y el cierre, como la contabilidad de inicio de sesión. Proporciona dos primitives:

** man:pam_open_session[3] realiza las tareas asociadas con la configuración de la sesión: añade una entrada a las bases de datos de [.filename]#utmp# y [.filename]#wtmp#, inicia un agente SSH, etc...
** man:pam_close_session[3] realiza tareas asociadas con el cierre de la sesión: agrega una entrada a las bases de datos [.filename]#utmp# y [.filename]#wtmp#, detiene el agent SSH, etc...

`password`::
_Gestión de contraseñas._ Esta función se usa para cambiar el token de autenticación asociado a una cuenta, ya sea porque ha caducado o porque el usuario desea cambiarla. Proporciona una primitive única:

** man:pam_chauthtok[3] cambia el token de autenticación, verificando opcionalmente que sea lo suficientemente difícil de adivinar, que no haya sido utilizado anteriormente, etc...

[[pam-modules]]
=== Módulos

Los módulos son la piedra angular de PAM; después de todo, son la "M", en "PAM". Un módulo PAM es un código de programación autónomo que implementa los primitives en una o más instalaciones para unas facilities en particular; los posibles mecanismos para la facility de autenticación, por ejemplo, incluyen la base de datos de contraseñas UNIX(TM), NIS, LDAP y Radius.

[[pam-module-naming]]
=== Nomenclatura de módulos

FreeBSD implementa cada mecanismo en un solo módulo, llamado `pam__mechanism_.so` (por ejemplo, `pam_unix.so` para el motor UNIX(TM)). Otras implementaciones a veces tienen módulos separados para instalaciones separadas, e incluyen el nombre de la facility y el nombre del mecanismo en el nombre del módulo. Por mencionar un ejemplo, Solaris(TM) tiene un módulo `pam_dial_auth.so.1` que se utiliza comúnmente para autenticar a los usuarios por acceso telefónico.

[[pam-module-versioning]]
=== Versionado de módulos

La implementación original de PAM en FreeBSD, basada en Linux-PAM, no usaba números de versión para los módulos PAM. Esto normalmente causaría problemas con las aplicaciones heredadas (legacy), que podrían estar vinculadas con versiones anteriores de las bibliotecas del sistema, ya que no había forma de cargar una versión correspondiente de los módulos requeridos.

OpenPAM, por otro lado, busca módulos que tengan el mismo número de versión que la biblioteca PAM (actualmente 2), y solo recurre a un módulo sin versión si no se puede cargar un módulo que tenga versión. Por lo tanto, se pueden proporcionar módulos heredados (legacy) para aplicaciones heredadas (legacy), lo cual permite que las aplicaciones nuevas (o compiladas de nuevo) aprovechen los módulos más recientes.

Aunque los módulos PAM de Solaris(TM) generalmente tienen un número de versión, no están versionados realmente, porque el número es parte del nombre del módulo y debe incluirse en la configuración.

[[pam-chains-policies]]
=== Chains y policies

Cuando un server inicia una transacción PAM, la biblioteca PAM intenta cargar una policy para el service especificado en la llamada man:pam_start[3]. La policy especifica cómo se deben procesar las solicitudes de autenticación en un archivo de configuración. Este es otro de los conceptos centrales en PAM: la posibilidad de que el administrador ajuste la policy (en el sentido más amplio de la palabra) simplemente editando un archivo de texto.

Una policy consta de cuatro chains, una para cada una de las cuatro facilities de PAM. Cada chain es una secuencia de instalaciones de configuración, cada una especifica un módulo a invocar, algunos parámetros (opcionales) para pasar al módulo y una flag de control que describe cómo interpretar el código de retorno del módulo.

Comprender las flags de control es esencial para comprender los archivos de configuración de PAM. Hay cuatro flags de control diferentes:

`binding`::
Si el módulo tiene éxito y ningún módulo anterior en el chain ha fallado, el chain se terminará de inmediato y se otorgará la solicitud. Si el módulo falla, el resto de la chain se ejecuta, pero la solicitud finalmente se deniega.
+
Este flag de control fue introducido por Sun en Solaris(TM) 9 (SunOS(TM) 5.9), y también es compatible con OpenPAM.

`required`::
Si el módulo tiene éxito, el resto del chain se ejecutará, y la solicitud se otorgará a menos que otro módulo falle. Si el módulo falla, el resto del chain también se ejecutará, pero la solicitud será denegada al final.

`requisite`::
Si el módulo tiene éxito, el resto del chain se ejecutará y la solicitud se aceptará a menos que falle algún otro módulo. Si el módulo falla, el chain terminará inmediatamente y la solicitud será denegada.

`sufficient`::
Si el módulo tiene éxito y ningún módulo anterior del chain ha fallado, el chain terminará de inmediato y se aceptará la solicitud. Si el módulo fala, se ignorará y se ejecutará el resto del chain.
+
Como la semántica de este flag puede ser algo confusa, especialmente cuando se usa para el último módulo de un chain, se recomienda usar el flag de control del `binding` si la implementación lo admite.

`optional`::
El módulo se ejecuta, pero se ignora su resultado. Si todos los módulos de un chain están marcados como `optional`, todas las solicitudes serán aceptadas.

Cuando un server invoca una de las seis primitives de PAM, PAM recupera el chain para la facility a la que pertenece la primitive e invoca cada uno de los módulos enumerados en el chain, en el orden en el que se enumeran, hasta que llega al final, o determina que no es necesario ningún procesamiento adicional (porque un módulo `binding` o `sufficient` tuvo éxito, o porque falló un módulo `requisite`). La solicitud es aceptada si y solo si se invocó al menos un módulo, y todos los módulos que no sean opcionales tuvieron éxito.

Tenga en cuenta que es posible, aunque no muy común, tener el mismo módulo listado varias veces en el mismo chain. Por ejemplo, un módulo que busca nombres de usuario y contraseñas en un servidor de directorio podría invocarse varias veces con diferentes parámetros que especifican diferentes servidores de directorio para contactar. PAM trata diferentes ocurrencias del mismo módulo en el mismo chain como módulos diferentes no relacionados.

[[pam-transactions]]
=== Transacciones

El ciclo de vida de una transacción PAM típica se describe a continuación. Tenga en cuenta que si alguno de estos pasos falla, el servidor debe informar con un mensaje de error adecuado al cliente y cancelar la transacción.

. Si es necesario, el servidor obtiene las credenciales del arbitrator a través de un mecanismo independente de PAM--comúnmente en virtud de haber sido iniciado por el usuario `root`, o por setuid `root`.
. El server llama a man:pam_start[3] para inicializar la biblioteca PAM y especificar su nombre de servicio y la cuenta de destino, y registrar una función de conversación adecuada.
. El servidor obtiene información relacionada con la transacción (como el nombre de usuario del applicant y el nombre del host en el que se ejecuta el client) y la envía a PAM usando man:pam_set_item[3].
. El servidor llama a man:pam_authenticate[3] para autenticar al applicant.
. El server llama a man:pam_acct_mgmt[3] para verificar que la cuenta solicitada esté disponible y sea válida. Si la contraseña es correcta pero ha expirado, man:pam_acct_mgmt[3] devolverá `PAM_NEW_AUTHTOK_REQD` en lugar de `PAM_SUCCESS`.
. Si el paso anterior devolvió `PAM_NEW_AUTHTOK_REQD`, el servidor ahora llamará a man:pam_chauthtok[3] para obligar al cliente a cambiar el token de autenticación para la cuenta solicitada.
. Ahora que el applicant se ha autenticado correctamente, el server llama a man:pam_setcred[3] para establecer las credenciales de la cuenta solicitada. Puede hacerlo porque actúa en nombre del arbitrator y tiene las credenciales del arbitrator.
. Una vez que se han establecido las credenciales correctas, el server llamará a man:pam_open_session[3] para configurar la sesión.
. El server ahora realiza cualquier servicio que solicite el cliente--por ejemplo, proporciona al applicant un shell.
. Una vez que el server termina de servir al cliente, llama a man:pam_close_session[3] para eliminar la sesión.
. Finalmente, el server llama a man:pam_end[3] para notificar a la libreria de PAM que está hecho y que puede liberar cualquier recurso que haya sido asignado en el curso de la transacción.

[[pam-config]]
== Configuración de PAM

[[pam-config-file]]
=== Archivos de configuración de PAM

[[pam-config-pam-conf]]
=== El archivo [.filename]#/etc/pam.conf#

El archivo de configuración tradicional de PAM es [.filename]#/etc/pam.conf#. Este archivo contiene todas las configuraciones de PAM para su sistema. Cada línea del archivo describe un paso es un chain, como se muestra a continuación:

[.programlisting]
....
login   auth    required        pam_nologin.so  no_warn
....

Los campos son, en orden de aparición: nombre del servicio, nombre del facility, flag de control, nombre del módulo y argumentos del módulo. Cualquier campo adicional se interpreta como un argumento adicional del módulo.

Se contruye un chain separado para cada par service/facility, por lo tanto, si bien el orden en que aparecen las líneas para el mismo service y facility es significativo, el orden en que se enumeran los services y facilities no lo es. Los ejemplos en el documento PAM original agruparon las líneas de configuración por facility, y el [.filename]#pam.conf# que hay por defecto en Solaris(TM) todavía lo hace, pero la configuración por defecto de FreeBSD agrupa las líneas de configuración por service. De todas formas está bien; de cualquier forma, tiene el mismo sentido.

[[pam-config-pam-d]]
=== El archivo [.filename]#/etc/pam.d#

OpenPAM y Linux-PAM soportan un mecanismo de configuración alternativo, que es el mecanismo preferido en FreeBSD. En este esquema, cada policy está contenida en un archivo separado con el nombre del service al que se aplica. Estos archivos se almacenan en [.filename]#/etc/pam.d/#.

Estos archivos de policy por servicio tienen solo cuatro campos en lugar de los cinco de [.filename]#pam.conf#: el campo del nombre del service se omite, Por lo tanto, en lugar de la línea de ejemplo [.filename]#pam.conf# de la sección anterior, debería tener la siguiente línea en [.filename]#/etc/pam.d/login#:

[.programlisting]
....
auth    required        pam_nologin.so  no_warn
....

Como resultado de esta sintaxis simplificada, es posible utilizar la misma policy para múltiples services vinculando cada nombre de service al mismo archivo de policy. Por ejemplo, para utilizar la misma policy para `su` y `sudo`, puede hacer lo siguiente:

[source,bash]
....
# cd /etc/pam.d
# ln -s su sudo
....

Esto funciona porque el nombre del service se determina a partir del nombre del archivo en lugar de especificarse en el archivo de policy, por lo que el mismo archivo se puede usar para múltiples services con nombres diferentes.

Como la policy de cada service se almacena en un archivo separado, el mecanismo [.filename]#pam.d# también facilita la instalación de policies adicionales para paquetes de software de terceros.

[[pam-config-file-order]]
=== El orden de búsqueda del policy

Como hemos visto anteriormente, las policies de PAM se pueden encontrar en varios sitios. ¿Qué sucede si existen policies para el mismo service en varios sitios?

Es esencial comprender que el sistema de configuración de PAM se centra en los chains.

[[pam-config-breakdown]]
=== Desglose de una línea de configuración

Como se explica en la <<pam-config-file>>, cada línea en el archivo [.filename]#/etc/pam.conf# consta de cuatro o más campos: el nombre del service, el nombre de la facility, el flag de control, el nombre del módulo y cero o más argumentos del módulo.

El nombre del service suele ser (aunque no siempre) el nombre de la aplicación a la que se aplica la declaración. Si no está seguro, consulte la documentación de la aplicación para determinar qué nombre de service utiliza.

Tenga en cuenta que si usa [.filename]#/etc/pam.d/# en lugar de [.filename]#/etc/pam.conf#, el nombre del service se especifica mediante el nombre del archivo de policy y se omite de las líneas de configuración actuales, que luego empiezan con el nombre de la facility.

La facility es una de las cuatro palabras clave descritas en <<pam-facilities-primitives>>.

Del mismo modo, el flag de control es una de las cuatro palabras clave descritas en la <<pam-chains-policies>>, la cual describe cómo interpretar el código de retorno del módulo. Linux-PAM admite una sintaxis alternativa que le permite especificar la acción a asociar con cada posible código de retorno, pero esto debe ser evitado, ya no es estándar y está estrechamente relacionado con la forma en la que Linux-PAM realiza el dispacher de las llamadas del service (que difiere mucho de como lo hacen Solaris(TM) y OpenPAM). Como era de esperar, OpenPAM no admite esta sintaxis.

[[pam-policies]]
=== Policies

Para configurar PAM correctamente, es esencial comprender cómo se interpretan las policies.

Cuando una aplicación llama a man:pam_start[3], la biblioteca PAM carga el policy para el service especificado y construye cuatro chains (uno para cada policy). Si una o más de estas chains están vacías, se reemplazan las chains de la policy correspondiente para el service `other`.

Cuando la aplicación llama más tarde a una de los seis primitives de PAM, la biblioteca PAM recupera el chain para la facility correspondiente y llama a la función apropiada del service en cada módulo del listado en el chain, en el orden en el que fueron listados en la configuración. Después de cada llamada a una función del service, el tipo de módulo y el código de error devuelto por la función del service se utilizan para determinar qué sucede a continuación. Con algunas excepciones, que se analizaran a continuación, se aplica la siguiente tabla:

.Resumen de la ejecución del chain en PAM
[cols="1,1,1,1", options="header"]
|===
| 
| PAM_SUCCESS
| PAM_IGNORE
| Otros

|binding
|if (!fail) break;
|-
|fail = true;

|required
|-
|-
|fail = true;

|requisite
|-
|-
|fail = true; break;

|sufficient
|if (!fail) break;
|-
|-

|optional
|-
|-
|-
|===

Si `fail` es true al final de un chain, o cuando se alcanza un "break", el dispatcher devuelve el código de error devuelto el primer módulo que falló. De lo contrario, devuelve `PAM_SUCCESS`.

La primera excepción es que el código de error `PAM_NEW_AUTHTOK_REQD` se trata como un éxito, si ningún módulo falla y al menos un módulo devuelve `PAM_NEW_AUTHTOK_REQD`, el dispatcher devolverá `PAM_NEW_AUTHTOK_REQD`.

La segunda excepción es que man:pam_setcred[3] trata los módulos `binding` y `sufficient` como si fueran `required`.

La tercera y última excepción es que man:pam_chauthtok[3] ejecuta la chain completa dos veces (una para verificaciones preliminares y otra para establecer la contraseña), y en la fase preliminar, trata los módulos `binding` y `sufficient` como si fueran `required`.

[[pam-freebsd-modules]]
== Módulos PAM de FreeBSD

[[pam-modules-deny]]
=== man:pam_deny[8]

El módulo man:pam_deny[8] es uno de los módulos más simples de los módulos que hay disponibles; responde a cualquier solicitud con `PAM_AUTH_ERR`. Es útil para deshabilitar rápidamente un servicio (añadalo al principio de cada chain) o para terminar chains de módulos `sufficient`.

[[pam-modules-echo]]
=== man:pam_echo[8]

El módulo man:pam_echo[8] simplemente pasa sus argumentos a la función de conversación como un mensaje `PAM_TEXT_INFO`. Se utiliza principalmente para la depuración, pero también puede servir para mostrar mensajes como "Unauthorized access will be prosecuted" antes de comenzar el procedimiento de autenticación.

[[pam-modules-exec]]
=== man:pam_exec[8]

El módulo man:pam_exec[8] coge su primer argumento del nombre del programa a ejecutar, y el resto de argumentos se pasan a ese programa como argumentos de línea de comandos. Un posible uso sería para ejecutar un programa que al iniciar la sesión monte el directorio home del usuario.

[[pam-modules-ftpusers]]
=== man:pam_ftpusers[8]

El módulo man:pam_ftpusers[8]

[[pam-modules-group]]
=== man:pam_group[8]

El módulo man:pam_group[8] acepta o rechaza a los applicants en función de su pertenencia a un grupo de archivos en particular (normalmente `wheel` para man:su[1]). Su principal objetivo es mantener el comportamiento tradicional de BSD man:su[1], pero tiene muchos otros usos, como la exclusión de ciertos grupos de usuarios de un servicio en particular.

[[pam-modules-guest]]
=== man:pam_guest[8]

El módulo man:pam_guest[8] permite el inicio de sesión de invitados utilizando nombres de inicio de sesión fijos. Se pueden introducir varios requisitos en la contraseña, pero el comportamiento predeterminado es permitir cualquier contraseña siempre que el nombre de inicio de sesión sea el de una cuenta de invitado. El módulo man:pam_guest[8] se puede utilizar fácilmente para implementar inicios de sesión en FTP anónimos.

[[pam-modules-krb5]]
=== man:pam_krb5[8]

El módulo man:pam_krb5[8]

[[pam-modules-ksu]]
=== man:pam_ksu[8]

El módulo man:pam_ksu[8]

[[pam-modules-lastlog]]
=== man:pam_lastlog[8]

El módulo man:pam_lastlog[8]

[[pam-modules-login-access]]
=== man:pam_login_access[8]

El módulo man:pam_login_access[8] proporciona una implementación de la primitive de administración de cuentas que aplica las restricciones en el inicio de sesión especificadas en la tabla man:login.access[5].

[[pam-modules-nologin]]
=== man:pam_nologin[8]

El módulo man:pam_nologin[8] rechaza los inicios de sesión que no sean del usuario root cuando existe el archivo [.filename]#/var/run/nologin#. Generalmente, este archivo se crea mediante el uso del comando man:shutdown[8] cuando quedan menos de cinco minutos hasta el tiempo de apagado programado.

[[pam-modules-opie]]
=== man:pam_opie[8]

El módulo man:pam_opie[8] implementa el método de autenticación man:opie[4]. El sistema man:opie[4] es un mecanismo de desafío-respuesta en el que la respuesta a cada desafío es una función directa del desafio y una contraseña, por lo que la respuesta puede ser calculada "just in time" por cualquier persona que posea la contraseña, eliminando la necesidad de listados de contraseñas. Además, dado que man:opie[4] nunca reutiliza un desafío que ya ha sido respondido correctamente, no es vulnerable a los ataques por repetición.

[[pam-modules-opieaccess]]
=== man:pam_opieaccess[8]

El módulo man:pam_opieaccess[8] es un módulo complementario para man:pam_opie[8]. Su propósito es hacer cumplir las restricciones codificadas en man:opieaccess[5], que regulan las condiciones bajo las cuales un usuario que normalmente se autenticaría usando man:opie[4] puede usar métodos alternativos. Esto se utiliza a menudo para prohibir el uso de autenticación por contraseña de host de los cuales no se tiene confianza.

Para que sea efectivo, el módulo man:pam_opieaccess[8] debe aparecer como `requisite` inmediatamente después de una entrada `sufficient` para man:pam_opie[8], y antes que cualquier otro módulo, en el chain `auth`.

[[pam-modules-passwdqc]]
=== man:pam_passwdqc[8]

El módulo man:pam_passwdqc[8]

[[pam-modules-permit]]
=== man:pam_permit[8]

El módulo man:pam_permit[8] es uno de los módulos más simples de los que hay disponibles; responde a cualquier solicitud con `PAM_SUCCESS`. Es útil para marcar la posición en los servicios donde una o más chains estarían vacías.

[[pam-modules-radius]]
=== man:pam_radius[8]

El módulo man:pam_radius[8]

[[pam-modules-rhosts]]
=== man:pam_rhosts[8]

El módulo man:pam_rhosts[8]

[[pam-modules-rootok]]
=== man:pam_rootok[8]

El módulo man:pam_rootok[8] informa de éxito si, y solo si, si el identificador del usuario real en el proceso que lo llama (se supone que lo ejecuta el applicant) es 0. Esto es útil para servicios no contectados en red, como man:su[1] o man:passwd[1], a los que `root` debe tener acceso automático.

[[pam-modules-securetty]]
=== man:pam_securetty[8]

El módulo man:pam_securetty[8]

[[pam-modules-self]]
=== man:pam_self[8]

El módulo man:pam_self[8] informa de éxito si y solo si, los nombres del applicant coinciden con los de la cuenta de destino. Es más útil para servicios no conectados en red como man:su[1], donde la identidad del solicitante se puede verificar fácilmente.

[[pam-modules-ssh]]
=== man:pam_ssh[8]

El módulo man:pam_ssh[8] proporciona servicios de autenticación y sesión. El servicio de autenticación permit a los usuarios que tienen claves secretas SSH protegidas con contraseña en su directorio [.filename]#~/.ssh# para autenticarse escribiendo su contraseña. El servicio de sesión inicia man:ssh-agent[1] y lo precarga con las claves que se descifraron en la fase de autenticación. Esta característica es particularmente útil para inicios de sesión locales, ya sea en X (usando man:xdm[1] u otro administrador de inicio de sesión en el entorno X compatible con PAM) o en la consola.

[[pam-modules-tacplus]]
=== man:pam_tacplus[8]

El módulo man:pam_tacplus[8]

[[pam-modules-unix]]
=== man:pam_unix[8]

El módulo man:pam_unix[8] implementa la autenticación con contraseña tradicional UNIX(TM), usando man:getpwnam[3] para obtener la contraseña de la cuenta de destino y compararla con la proporciona por el applicant. También proporciona servicios de administración de cuentas (cumplimiento con los tiempos de expiración de cuentas y contraseñas) y servicios de cambio de contraseñas. Este es probablemente el módulo más útil, ya que la gran mayoría de los administradores querrán mantener el comportamiento de siempre en al menos algunos servicios.

[[pam-appl-prog]]
== Programación de aplicaciones PAM

Esta sección aún no se ha escrito.

[[pam-module-prog]]
== Programación del módulo PAM

Esta sección aún no se ha escrito.

:sectnums!:

[appendix]
[[pam-sample-appl]]
== Ejemplo de aplicación PAM

El siguiente ejemplo es una implementación mínima del comando man:su[1] usando PAM. Tenga en cuenta que utiliza la función de conversación man:openpam_ttyconv[3] específica de OpenPAM, que tiene su prototipo en [.filename]#security/openpam.h#. Si desea compilar esta aplicación en un sistema con una libreria de PAM diferente, tendrá que proporcionar su propia función de conversación. Una función de conversación robusta es sorprendentemente difícil de implementar; el ejemplo del <<pam-sample-conv>> es un buen punto de partida, pero no debe utilizarse en aplicaciones del mundo real.

[.programlisting]
....
/*-
 * Copyright (c) 2002,2003 Networks Associates Technology, Inc.
 * All rights reserved.
 *
 * This software was developed for the FreeBSD Project by ThinkSec AS and
 * Network Associates Laboratories, the Security Research Division of
 * Network Associates, Inc.  under DARPA/SPAWAR contract N66001-01-C-8035
 * ("CBOSS"), as part of the DARPA CHATS research program.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $P4: //depot/projects/openpam/bin/su/su.c#10 $
 * $FreeBSD$
 */

#include <sys/param.h>
#include <sys/wait.h>

#include <err.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>

#include <security/pam_appl.h>
#include <security/openpam.h>	/* for openpam_ttyconv() */

extern char **environ;

static pam_handle_t *pamh;
static struct pam_conv pamc;

static void
usage(void)
{

	fprintf(stderr, "Usage: su [login [args]]\n");
	exit(1);
}

int
main(int argc, char *argv[])
{
	char hostname[MAXHOSTNAMELEN];
	const char *user, *tty;
	char **args, **pam_envlist, **pam_env;
	struct passwd *pwd;
	int o, pam_err, status;
	pid_t pid;

	while ((o = getopt(argc, argv, "h")) != -1)
		switch (o) {
		case 'h':
		default:
			usage();
		}

	argc -= optind;
	argv += optind;

	if (argc > 0) {
		user = *argv;
		--argc;
		++argv;
	} else {
		user = "root";
	}

	/* initialize PAM */
	pamc.conv = &openpam_ttyconv;
	pam_start("su", user, &pamc, &pamh);

	/* set some items */
	gethostname(hostname, sizeof(hostname));
	if ((pam_err = pam_set_item(pamh, PAM_RHOST, hostname)) != PAM_SUCCESS)
		goto pamerr;
	user = getlogin();
	if ((pam_err = pam_set_item(pamh, PAM_RUSER, user)) != PAM_SUCCESS)
		goto pamerr;
	tty = ttyname(STDERR_FILENO);
	if ((pam_err = pam_set_item(pamh, PAM_TTY, tty)) != PAM_SUCCESS)
		goto pamerr;

	/* authenticate the applicant */
	if ((pam_err = pam_authenticate(pamh, 0)) != PAM_SUCCESS)
		goto pamerr;
	if ((pam_err = pam_acct_mgmt(pamh, 0)) == PAM_NEW_AUTHTOK_REQD)
		pam_err = pam_chauthtok(pamh, PAM_CHANGE_EXPIRED_AUTHTOK);
	if (pam_err != PAM_SUCCESS)
		goto pamerr;

	/* establish the requested credentials */
	if ((pam_err = pam_setcred(pamh, PAM_ESTABLISH_CRED)) != PAM_SUCCESS)
		goto pamerr;

	/* authentication succeeded; open a session */
	if ((pam_err = pam_open_session(pamh, 0)) != PAM_SUCCESS)
		goto pamerr;

	/* get mapped user name; PAM may have changed it */
	pam_err = pam_get_item(pamh, PAM_USER, (const void **)&user);
	if (pam_err != PAM_SUCCESS || (pwd = getpwnam(user)) == NULL)
		goto pamerr;

	/* export PAM environment */
	if ((pam_envlist = pam_getenvlist(pamh)) != NULL) {
		for (pam_env = pam_envlist; *pam_env != NULL; ++pam_env) {
			putenv(*pam_env);
			free(*pam_env);
		}
		free(pam_envlist);
	}

	/* build argument list */
	if ((args = calloc(argc + 2, sizeof *args)) == NULL) {
		warn("calloc()");
		goto err;
	}
	*args = pwd->pw_shell;
	memcpy(args + 1, argv, argc * sizeof *args);

	/* fork and exec */
	switch ((pid = fork())) {
	case -1:
		warn("fork()");
		goto err;
	case 0:
		/* child: give up privs and start a shell */

		/* set uid and groups */
		if (initgroups(pwd->pw_name, pwd->pw_gid) == -1) {
			warn("initgroups()");
			_exit(1);
		}
		if (setgid(pwd->pw_gid) == -1) {
			warn("setgid()");
			_exit(1);
		}
		if (setuid(pwd->pw_uid) == -1) {
			warn("setuid()");
			_exit(1);
		}
		execve(*args, args, environ);
		warn("execve()");
		_exit(1);
	default:
		/* parent: wait for child to exit */
		waitpid(pid, &status, 0);

		/* close the session and release PAM resources */
		pam_err = pam_close_session(pamh, 0);
		pam_end(pamh, pam_err);

		exit(WEXITSTATUS(status));
	}

pamerr:
	fprintf(stderr, "Sorry\n");
err:
	pam_end(pamh, pam_err);
	exit(1);
}
....


:sectnums!:

[appendix]
[[pam-sample-module]]
== Ejemplo de módulo PAM

El siguiente ejemplo es una implementación mínima de man:pam_unix[8], ofrece solo servicios de autenticación. Debería de compilarse y ejecutarse con la mayoría de las implementaciones de PAM, pero aprovecha las extensiones de OpenPAM si están disponibles: tenga en cuenta el uso de man:pam_get_authtok[3], que simplifica enormemente la solicitud de una contraseña al usuario.

[.programlisting]
....
/*-
 * Copyright (c) 2002 Networks Associates Technology, Inc.
 * All rights reserved.
 *
 * This software was developed for the FreeBSD Project by ThinkSec AS and
 * Network Associates Laboratories, the Security Research Division of
 * Network Associates, Inc.  under DARPA/SPAWAR contract N66001-01-C-8035
 * ("CBOSS"), as part of the DARPA CHATS research program.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $P4: //depot/projects/openpam/modules/pam_unix/pam_unix.c#3 $
 * $FreeBSD$
 */

#include <sys/param.h>

#include <pwd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include <security/pam_modules.h>
#include <security/pam_appl.h>

#ifndef _OPENPAM
static char password_prompt[] = "Password:";
#endif

#ifndef PAM_EXTERN
#define PAM_EXTERN
#endif

PAM_EXTERN int
pam_sm_authenticate(pam_handle_t *pamh, int flags,
	int argc, const char *argv[])
{
#ifndef _OPENPAM
	struct pam_conv *conv;
	struct pam_message msg;
	const struct pam_message *msgp;
	struct pam_response *resp;
#endif
	struct passwd *pwd;
	const char *user;
	char *crypt_password, *password;
	int pam_err, retry;

	/* identify user */
	if ((pam_err = pam_get_user(pamh, &user, NULL)) != PAM_SUCCESS)
		return (pam_err);
	if ((pwd = getpwnam(user)) == NULL)
		return (PAM_USER_UNKNOWN);

	/* get password */
#ifndef _OPENPAM
	pam_err = pam_get_item(pamh, PAM_CONV, (const void **)&conv);
	if (pam_err != PAM_SUCCESS)
		return (PAM_SYSTEM_ERR);
	msg.msg_style = PAM_PROMPT_ECHO_OFF;
	msg.msg = password_prompt;
	msgp = &msg;
#endif
	for (retry = 0; retry < 3; ++retry) {
#ifdef _OPENPAM
		pam_err = pam_get_authtok(pamh, PAM_AUTHTOK,
		    (const char **)&password, NULL);
#else
		resp = NULL;
		pam_err = (*conv->conv)(1, &msgp, &resp, conv->appdata_ptr);
		if (resp != NULL) {
			if (pam_err == PAM_SUCCESS)
				password = resp->resp;
			else
				free(resp->resp);
			free(resp);
		}
#endif
		if (pam_err == PAM_SUCCESS)
			break;
	}
	if (pam_err == PAM_CONV_ERR)
		return (pam_err);
	if (pam_err != PAM_SUCCESS)
		return (PAM_AUTH_ERR);

	/* compare passwords */
	if ((!pwd->pw_passwd[0] && (flags & PAM_DISALLOW_NULL_AUTHTOK)) ||
	    (crypt_password = crypt(password, pwd->pw_passwd)) == NULL ||
	    strcmp(crypt_password, pwd->pw_passwd) != 0)
		pam_err = PAM_AUTH_ERR;
	else
		pam_err = PAM_SUCCESS;
#ifndef _OPENPAM
	free(password);
#endif
	return (pam_err);
}

PAM_EXTERN int
pam_sm_setcred(pam_handle_t *pamh, int flags,
	int argc, const char *argv[])
{

	return (PAM_SUCCESS);
}

PAM_EXTERN int
pam_sm_acct_mgmt(pam_handle_t *pamh, int flags,
	int argc, const char *argv[])
{

	return (PAM_SUCCESS);
}

PAM_EXTERN int
pam_sm_open_session(pam_handle_t *pamh, int flags,
	int argc, const char *argv[])
{

	return (PAM_SUCCESS);
}

PAM_EXTERN int
pam_sm_close_session(pam_handle_t *pamh, int flags,
	int argc, const char *argv[])
{

	return (PAM_SUCCESS);
}

PAM_EXTERN int
pam_sm_chauthtok(pam_handle_t *pamh, int flags,
	int argc, const char *argv[])
{

	return (PAM_SERVICE_ERR);
}

#ifdef PAM_MODULE_ENTRY
PAM_MODULE_ENTRY("pam_unix");
#endif
....


:sectnums!:

[appendix]
[[pam-sample-conv]]
== Ejemplo de función de conversación PAM

La función de conversación presentada a continuación es una versión muy simplificada de man:openpam_ttyconv[3] de OpenPAM. Es completamente funcional y debería de dar al lector una buena idea de cómo debería de comportarse una función de conversación, pero es demasiado simple para su uso en el mundo real. Incluso si no está utilizando OpenPAM, no dude en descargar el código fuente y adaptar man:openpam_ttyconv[3] a sus necesidades; creemos que es tan robusta como lo puede ser una función de conversación orientada a tty.

[.programlisting]
....
/*-
 * Copyright (c) 2002 Networks Associates Technology, Inc.
 * All rights reserved.
 *
 * This software was developed for the FreeBSD Project by ThinkSec AS and
 * Network Associates Laboratories, the Security Research Division of
 * Network Associates, Inc.  under DARPA/SPAWAR contract N66001-01-C-8035
 * ("CBOSS"), as part of the DARPA CHATS research program.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD$
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <security/pam_appl.h>

int
converse(int n, const struct pam_message **msg,
	struct pam_response **resp, void *data)
{
	struct pam_response *aresp;
	char buf[PAM_MAX_RESP_SIZE];
	int i;

	data = data;
	if (n <= 0 || n > PAM_MAX_NUM_MSG)
		return (PAM_CONV_ERR);
	if ((aresp = calloc(n, sizeof *aresp)) == NULL)
		return (PAM_BUF_ERR);
	for (i = 0; i < n; ++i) {
		aresp[i].resp_retcode = 0;
		aresp[i].resp = NULL;
		switch (msg[i]->msg_style) {
		case PAM_PROMPT_ECHO_OFF:
			aresp[i].resp = strdup(getpass(msg[i]->msg));
			if (aresp[i].resp == NULL)
				goto fail;
			break;
		case PAM_PROMPT_ECHO_ON:
			fputs(msg[i]->msg, stderr);
			if (fgets(buf, sizeof buf, stdin) == NULL)
				goto fail;
			aresp[i].resp = strdup(buf);
			if (aresp[i].resp == NULL)
				goto fail;
			break;
		case PAM_ERROR_MSG:
			fputs(msg[i]->msg, stderr);
			if (strlen(msg[i]->msg) > 0 &&
			    msg[i]->msg[strlen(msg[i]->msg) - 1] != '\n')
				fputc('\n', stderr);
			break;
		case PAM_TEXT_INFO:
			fputs(msg[i]->msg, stdout);
			if (strlen(msg[i]->msg) > 0 &&
			    msg[i]->msg[strlen(msg[i]->msg) - 1] != '\n')
				fputc('\n', stdout);
			break;
		default:
			goto fail;
		}
	}
	*resp = aresp;
	return (PAM_SUCCESS);
 fail:
        for (i = 0; i < n; ++i) {
                if (aresp[i].resp != NULL) {
                        memset(aresp[i].resp, 0, strlen(aresp[i].resp));
                        free(aresp[i].resp);
                }
        }
        memset(aresp, 0, n * sizeof *aresp);
	*resp = NULL;
	return (PAM_CONV_ERR);
}
....


:sectnums!:

[[pam-further]]
== Lecturas adicionales

=== Artículos

Hacer que los servicios de acceso sean independientes de las tecnologías de autenticación. Vipin Samar y Charlie Lai. Sun Microsystems.

_link:https://pubs.opengroup.org/onlinepubs/8329799/toc.htm[X/Open Single Sign-on Preliminary Specification]_. The Open Group. 1-85912-144-6. June 1997.

_link:https://mirrors.kernel.org/pub/linux/libs/pam/pre/doc/draft-morgan-pam-07.txt[Pluggable Authentication Modules]_. Andrew G. Morgan. 1999-10-06.

=== Manuales de usuario

_link:https://docs.oracle.com/cd/E26505_01/html/E27224/pam-1.html[PAM Administration]_. Sun Microsystems.

=== Páginas web relacionadas

_link:https://www.openpam.org/[OpenPAM homepage]_ Dag-Erling Smørgrav. ThinkSec AS.

_link:http://www.kernel.org/pub/linux/libs/pam/[Linux-PAM homepage]_ Andrew Morgan.

_Solaris PAM homepage_. Sun Microsystems.
